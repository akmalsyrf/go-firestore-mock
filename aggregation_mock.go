// Code generated by MockGen. DO NOT EDIT.
// Source: aggregation.go
//
// Generated by this command:
//
//	mockgen -source=aggregation.go -destination=aggregation_mock.go -package=firestore
//
// Package firestore is a generated GoMock package.
package firestore

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockAggregationQuery is a mock of AggregationQuery interface.
type MockAggregationQuery struct {
	ctrl     *gomock.Controller
	recorder *MockAggregationQueryMockRecorder
}

// MockAggregationQueryMockRecorder is the mock recorder for MockAggregationQuery.
type MockAggregationQueryMockRecorder struct {
	mock *MockAggregationQuery
}

// NewMockAggregationQuery creates a new mock instance.
func NewMockAggregationQuery(ctrl *gomock.Controller) *MockAggregationQuery {
	mock := &MockAggregationQuery{ctrl: ctrl}
	mock.recorder = &MockAggregationQueryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregationQuery) EXPECT() *MockAggregationQueryMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockAggregationQuery) Get(ctx context.Context) (AggregationResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx)
	ret0, _ := ret[0].(AggregationResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockAggregationQueryMockRecorder) Get(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockAggregationQuery)(nil).Get), ctx)
}

// WithCount mocks base method.
func (m *MockAggregationQuery) WithCount(alias string) AggregationQuery {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithCount", alias)
	ret0, _ := ret[0].(AggregationQuery)
	return ret0
}

// WithCount indicates an expected call of WithCount.
func (mr *MockAggregationQueryMockRecorder) WithCount(alias any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithCount", reflect.TypeOf((*MockAggregationQuery)(nil).WithCount), alias)
}

// MockAggregationResult is a mock of AggregationResult interface.
type MockAggregationResult struct {
	ctrl     *gomock.Controller
	recorder *MockAggregationResultMockRecorder
}

// MockAggregationResultMockRecorder is the mock recorder for MockAggregationResult.
type MockAggregationResultMockRecorder struct {
	mock *MockAggregationResult
}

// NewMockAggregationResult creates a new mock instance.
func NewMockAggregationResult(ctrl *gomock.Controller) *MockAggregationResult {
	mock := &MockAggregationResult{ctrl: ctrl}
	mock.recorder = &MockAggregationResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregationResult) EXPECT() *MockAggregationResultMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockAggregationResult) Count(alias string) (*int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", alias)
	ret0, _ := ret[0].(*int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockAggregationResultMockRecorder) Count(alias any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockAggregationResult)(nil).Count), alias)
}
